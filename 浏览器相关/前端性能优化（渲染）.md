# 关于渲染性能优化

* 避免重复渲染

## 1、requestAnimationFrame(func(time))

* ​	该函数类似于定时器，传入一个回调函数（本来是用于传入一个动画），在浏览器下一次重绘之前调用该函数。时间间隔一般是16.7ms(取决于显示屏刷新率)，也就是1000/60，因为大多数显示屏都是60帧的刷新率。

* ​    该函数还会自动对回调函数添加一个参数，用于表示在何时调用该回调函数。如果需要降低函数调用的频率，可以获取该事件并进行条件判断。

* ​    对于要实现（优化）动画效果，应该在回调函数中再次调用requestAnimationFrame()，达到重复更新。

### 优势

1、函数节流，该函数会把这一帧中的所有重绘/回流操作，整合成一次。相对于定时器方法，该函数可以避免丢帧现象。因为数值更新操作固定按照屏幕刷新前来进行。

2、如果把网页调换到后台不显示，该函数将不再调用，而计时器却会一直进行，造成CPU的资源浪费。

## 2、保持dom操作的原子性

​		**浏览器对于一段代码中频繁改变的样式(颜色、边框)，并不会每一次都会发生重绘/回流，而是会维持一个队列。经过一定时间或者队列长度，才会对队列中的操作flush，整合成一次操作，减少dom的修改次数**

> ​	**但对于一些特殊情况则会立即去flush队列，对性能造成影响。如：**
>
> > 1. offsetTop, offsetLeft, offsetWidth, offsetHeight
> >
> > 2. scrollTop/Left/Width/Height
> > 3. clientTop/Left/Width/Height
> > 4. width,height
> > 5. 请求了getComputedStyle(), 或者 ie的 currentStyle

> **因为要给用户获取到最精确的值**

​	因此，在一段代码中，应尽量保证把获取dom元素参数的代码放在一起，修改dom元素参数的代码放在一起。而不是获取一个修改一个、获取一个修改一个，这样会造成多次布局计算。

![image-20200916111732799](C:\Users\pc\AppData\Roaming\Typora\typora-user-images\image-20200916111732799.png)

## 3、使用classList，而非className来修改dom样式

​	className每修改一次就会造成一次渲染布局。

​	classList则浏览器会先去进行样式名的判断，再进行渲染布局，以减少不必要的重复渲染。

## 4、降低css选择器计算复杂度(BEM命名规范)

​	将拥有多层命名的选择器简化为一个单独的命名。使用BEM(Block-Element-Modifier)命名规范。

id+伪类+类——>id(class)

## 5、transform和opacity创建新图层来实现动画

​	新图层的创建使本元素与其他元素相隔开形成不同图层，这样所有的dom改变都只会修改本图层的布局，而不会影响其他图层的布局。

​	另一个属性will-change:transform来提示浏览器将要发生的操作，让浏览器提前准备优化工作。但不可滥用，影响资源开销。

原因：

> opacity：
>
> **MDN原文：使用opacity属性，当属性值不为1时，会把元素放置在一个新的[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)中。**
>
> ​	属性本身是用于处理一个图层中重叠部分的颜色。该属性会创建一个新的图层，在图层合成阶段经过RGB颜色混合，在新图层中保存一个原来元素在原图层的RGB像素值缓存，而且该缓存在新图层中不需要更新。这样就不需要进行RBG颜色的重复计算，也就不需要重绘、不影响布局了。
>
> 
>
> transform:
>
> ​	transform性能高，本质原因类似于opacity，而并不是因为硬件加速。这时缓存的是一个二位/三位的齐次矩阵，用于如下函数计算
>
> 平移translate()，缩放scale()，斜切skew()，旋转rotate()。

个人理解：

**不使用两个属性时：**

获取原点信息(0,0)——计算，改变一次——>(0,1)

计算并获取(0,1)信息——>计算，改变一次——>(0,2)

**使用两个属性时：**

获取原点信息(0,0)——计算并改变——>(0,1)

使用原点信息缓存(0,0)——>计算并改变——>(0,2)