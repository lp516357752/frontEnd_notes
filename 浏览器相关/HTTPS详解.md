# 前端安全相关

* HTTPS协议是在http协议的基础上加上SSL(安全套接层)或者说TSL(安全传输层协议)协议而形成的。TSL是SSL的后续版本更改的名字。
* 密文复杂度与加密方法、原数据长度都相关。

## 一、明文传输

​	明文传输极其不安全，黑客截取到报文数据后可以直接拿到里面的数据。

## 二、对称加密(pass)

​	对称加密指的是客户端和服务端拥有同一个密钥，其中每一对S/C都拥有一个专属密钥，双方在发送数据时都把数据用该密钥进行加密，对方接收到后用**相同的密钥**进行解密。

**缺点：（S——>C，C——>S都不安全）**

* 如果各自***密钥不同***，则每一对S/C都有一套专属密钥，对于亿万级用户量，服务器存储负担大，很不现实。
* 如果各自***密钥相同***，则就类似于明文传输了，任何用户都可以拥有成为黑客的潜质。

## 三、非对称加密(pass)

​	客户端用公钥对数据进行加密，服务端使用私钥对数据进行解密。服务端用私钥对数据进行加密，客户端使用公钥对数据进行解密。公钥对外开放，请求即可获得，私钥服务端独享。

* 客户端发送密文给服务端，服务端使用私钥进行解密，黑客拿到报文也无法解密。即**客户端到服务端会变得安全。**

**缺点（S——>C不安全）：**

* 服务端用私钥对数据进行加密，发送给客户端，此时黑客截获到数据之后，由于公钥是任何人都拥有的，这样是不可行的。

## 四、非对称加密+对称加密(pass)

​	即非对称加密商讨对称加密密钥，对称加密密钥用于数据传输传密。

​	客户端发起请求向客户端索取公钥，客户端随机生成一个数number当作对称加密密钥，并通过获取到的公钥对其加密。服务端用私钥对客户端发来的数据进行解密获取到number。此时可能还会告诉客户端已经OK。此后利用number当作对称加密密钥进行交互。

**缺点（MIME中间人）：**

* MITM(中间人)，在客户端请求公钥时，黑客当作了中间人，自己创造一个私钥，向客户端发送了自己的假公钥。同时向服务端请求公钥获取到了真实公钥。
* 之后黑客截获客户端发送的number数据，获得了number。同时也向服务器用真实公钥加密number发给服务端，让服务端获取number。
* 此后黑客充当中间人进行数据截获。

## 五、哈希加密算法

​	hash算法用于将一段原始数据转化成一段固定长度的符号串(**信息摘要**)，具有多对一的特点。不同数据加密形成的密文都会不同，但同一段密文可能会对应不同的原始数据。

​	hash算法是不可逆的，无法把密文转化回原始数据。但在S/C交互过程中，我们也不需要把密文还原成原数据，只需要把发过来的数据再hash一次再进行比较即可。一般后端在存储hash数据时，还需要对hash数据在进行一次hash算法才存进数据库。

​	常用算法：MD5算法、SHA-1算法、XOR、加盐、慢哈希。

​	例子：如重置密码时返回的一段随机的无规则数或一个邮箱中的链接。

### 1、加盐算法

​	即把原数据与一串n位的随机数(即盐)进行hash生成散列值，后端把盐值与用户关联到数据库，存储散列值。下次用户在进行登陆时，用对应盐值再对数据进行一次hash，对比之前存储的散列值和这次形成的散列值。

* 应使用安全伪随机数生成器来生成盐值
* 应使用足够长的盐值加进行加密，至少与原串长度相同。
* 加密算法要标准
* 应后端提供盐值。

## 六、HTTPS交互

1. CA认证机构解决了中间人问题。
2. 非对称加密(安全)+对称加密(快速)。

### 1、中间人问题的解决(CA)：

* CPK即解密证书的密钥，是对外开放的，由网客户端站进行存储、维护。

* 目的是需要安全的获取的服务端公钥

1. 服务端拥有公钥和私钥，服务端向CA机构获取证书(类似于非对称加密)，证书中包含着自己的公钥和证书相关信息。
2. 服务器返回给客户端自己的证书信息，客户端使用CPK对证书进行认证，检验证书机构、过期信息等。

### 2、过程

1. 客户端请求服务端，发送自己支持的SSL版本，支持的加密算法以及一个随机数a。
2. 服务端返回选取的加密算法、SSL版本、以及一个随机数b。
3. 服务端接着返回自己的证书，其中包含了公钥。
4. 客户端使用CA机构公开的证书认证密钥来认证证书，假设成功。
5. 客户端使用加密算法产生预主密钥preMaster key，用hash算法对第一步和第二步的所有数据进行hash，产生一个数据X，将X和使用公钥加密后的预主密钥preMaster key发给客户端。
6. 服务端同样用hash算法对第一步和第二步的所有数据进行hash产生y，使用私钥解密X后，检验X是否等于y。检验正确后，服务端也获得了预主密钥preMaster key。
7. 后续双方通过随机数和获得的预主密钥生成最终的对话密钥session key，并互相再发送一次消息确认双方的SSL安全连接已经建立。
8. 此后数据的交互就用会话密钥session key来进行。
