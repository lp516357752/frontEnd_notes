总体思路就是：

1、静态的单个元素、多个元素、绑定事件进行静态提升或者缓存，以达到复用（复用静态元素）

2、页面更新，对比节点时，使用blocktree记录动态节点，只比较动态节点（只比较动态元素）

3、对比信息时只对比记录的存在变化的信息（只比较节点存在变化的信息类型）

#### 1、静态提升

**静态元素：**vue3的render函数中，现在会将一些静态元素（指纯元素节点，未绑定任何动态数据）进行提升成外层的静态节点，指创建一次、渲染一次。（hoist）

**静态属性：**节点可能是动态的，如果其属性（如class）是固定的静态的，就会把其属性提升成一个静态对象来复用。

#### 2、预字符串化

vue3会将大量的(20个)连续的静态元素直接编译成一个普通的字符串节点

```javascript
<ul>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
  <li>1</li>
  <li6</li>
</ul>
<div>{{ test }}</div>
```

#### 3、缓存事件处理函数

保证事件函数只生成一次，以提高性能。

事件处理函数的绑定会认为是固定的，不会随数据变化而改变函数。即，vue3会优先从cache[0]缓存中查看是否有这个函数，有则返回，无则将其设置为该函数。

#### 4、BlockTree

vue3渲染函数生成的树结构里有个根节点block，根节点会包含1个其下的动态节点数据，以数组形式存储，重新渲染时循环对比动态节点数组里的每一项，以略过了全部的静态节点，提升效率。

当然，树的前后结构可能会不稳定，存在动态节点的增减，导致数组对应不上。于是Vue3会做特殊处理，将存在变化的节点所在的根节点区域也变成一个block块来处理。

#### 5、PatchFlag

就是vue3对比节点前后变化时，会记录节点具体是哪些信息会发生变化，用patchflag记录下来，比对时只比较这个标记类型的节点信息。

而vue2则是依次比对节点的信息